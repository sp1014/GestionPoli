{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap fce0cd39d130c49ddcd4","webpack:///./node_modules/cross-domain-utils/src/util.js","webpack:///./node_modules/cross-domain-utils/src/constants.js","webpack:///./node_modules/cross-domain-utils/src/utils.js","webpack:///./node_modules/cross-domain-safe-weakmap/src/util.js","webpack:///./node_modules/cross-domain-safe-weakmap/src/weakmap.js","webpack:///./node_modules/cross-domain-safe-weakmap/src/native.js","webpack:///./src/conf/constants.js","webpack:///./src/conf/config.js","webpack:///./src/lib/util.js","webpack:///./node_modules/zalgo-promise/src/utils.js","webpack:///./node_modules/zalgo-promise/src/exceptions.js","webpack:///./node_modules/zalgo-promise/src/flush.js","webpack:///./node_modules/zalgo-promise/src/promise.js","webpack:///./src/global.js","webpack:///./src/lib/serialize.js","webpack:///./src/lib/ready.js","webpack:///./src/drivers/send/strategies.js","webpack:///./src/drivers/send/index.js","webpack:///./src/drivers/listeners.js","webpack:///./src/drivers/receive/types.js","webpack:///./src/drivers/receive/index.js","webpack:///./src/public/client.js","webpack:///./src/public/server.js","webpack:///./src/public/config.js","webpack:///./src/public/index.js","webpack:///./src/clean.js","webpack:///./src/interface.js","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isRegex","item","toString","PROTOCOL","MOCK","FILE","ABOUT","WILDCARD","IE_WIN_ACCESS_ERROR","isAboutProtocol","arguments","length","undefined","window","location","protocol","getParent","win","parent","err","getOpener","opener","canReadFromWindow","href","getActualDomain","Error","host","getDomain","domain","mockDomain","indexOf","isActuallySameDomain","desc","getOwnPropertyDescriptor","isAncestorParent","child","childParent","result","push","getParents","getFrames","frames","len","frame","iframeWindows","iframeFrames","isWindowClosed","allowMock","closed","message","isSameDomain","mockclosed","top","iframeIndex","collection","safeIndexOf","contentWindow","parentNode","doc","ownerDocument","documentElement","contains","isFrameWindowClosed","getAncestor","matchDomain","pattern","origin","Array","isArray","Boolean","match","JSON","stringify","some","subpattern","isWindow","obj","Window","__cross_domain_utils_window_check__","CrossDomainSafeWeakMap","_classCallCheck","Math","random","WeakMap","freeze","testWeakMap","testKey","set","hasNativeWeakMap","weakmap","keys","values","_cleanupClosedWindows","value","splice","isSafeToReadWrite","key","entry","writable","index","has","getOrSet","CONSTANTS","POST_MESSAGE_TYPE","REQUEST","RESPONSE","ACK","POST_MESSAGE_ACK","SUCCESS","ERROR","POST_MESSAGE_NAMES","METHOD","HELLO","OPEN_TUNNEL","WINDOW_TYPES","FULLPAGE","POPUP","IFRAME","WINDOW_PROPS","POSTROBOT","SERIALIZATION_TYPES","PROMISE","ZALGO_PROMISE","REGEX","SEND_STRATEGIES","POST_MESSAGE","BRIDGE","GLOBAL","MOCK_PROTOCOL","FILE_PROTOCOL","BRIDGE_NAME_PREFIX","POSTROBOT_PROXY","CONFIG","map","ALLOW_POSTMESSAGE_POPUP","__ALLOW_POSTMESSAGE_POPUP__","BRIDGE_TIMEOUT","CHILD_WINDOW_TIMEOUT","ACK_TIMEOUT","navigator","userAgent","RES_TIMEOUT","ALLOWED_POST_MESSAGE_METHODS","_ALLOWED_POST_MESSAGE","ALLOW_SAME_ORIGIN","stringifyError","level","stack","newErr","once","method","called","apply","noop","uniqueID","chars","replace","charAt","floor","replaceObject","callback","depth","newobj","_typeof","TypeError","eachArray","eachObject","each","childItem","isPromise","Promise","constructor","then","dispatchedErrors","possiblyUnhandledPromiseHandlers","activeCount","flushPromise","flushActive","promise","resolve","startActive","endActive","ZalgoPromise","handler","_this","promise__classCallCheck","resolved","rejected","errorHandled","handlers","error","isAsync","res","reject","dispatch","_this2","setTimeout","j","dispatchPossiblyUnhandledError","asyncReject","dispatching","chain","firstPromise","secondPromise","_handlers$i","onSuccess","onError","onFinally","timeout","time","_this3","clearTimeout","toPromise","all","promises","count","results","prom","hash","items","onPossiblyUnhandledException","cancel","context","args","delay","flush","global","registerSelf","methods","listenForMethods","on","_ref","source","data","meth","id","isSerialized","type","serialize__typeof","__type__","serializeMethod","destination","__id__","__name__","deserializeMethod","wrapper","slice","send","_ref2","__xdomain__","deserializeZalgoPromise","__then__","sayHello","readyPromises","SEND_MESSAGE_STRATEGIES","serializedMessage","dom","forEach","postMessage","sendMessage","_jsonStringify","options","isPopup","isIframe","sourceDomain","_extends","windowType","buildMessage","__message__","__code__","code","serializePromise","serializeZalgoPromise","regex","__source__","serializeMethods","messages","replacer","indent","objectToJSON","arrayToJSON","toJSON","jsonStringify","strategyName","success","status","join","responseListeners","requestListeners","WINDOW_WILDCARD","erroredResponseListeners","__DOMAIN_REGEX__","getResponseListener","deleteResponseListener","isResponseListenerErrored","getRequestListener","nameListeners","_i2","_ref3","_length2","winQualifier","winListeners","_i4","_winListeners$__DOMAI2","_length4","_ref5","listener","RECEIVE_MESSAGE_TYPES","pathname","ack","_RECEIVE_MESSAGE_TYPE","respond","fireAndForget","types__extends","target","originalSource","handleError","response","receiveMessage","event","parsedMessage","parse","receive__typeof","parseMessage","receivedMessages","deserializePromise","RegExp","deserializeRegex","deserializeMethods","messageListener","sourceElement","originalEvent","request","targetWindow","el","document","getElementById","tagName","toLowerCase","HTMLIFrameElement","hasResult","requestPromises","requestPromise","actualParent","_i7","_getAllChildFrames4","getAllChildFrames","_i3","_getFrames2","_i5","_getAllChildFrames2","childFrame","_length6","getTop","_i15","_getFrames8","_length14","isAncestor","onChildWindowReady","actualDomain","responseListener","addResponseListener","ackTimeout","resTimeout","cycleTime","cycle","max","min","markResponseListenerErrored","sendToParent","client","listen","listenerOptions","errorHandler","requestListener","addRequestListener","_ref6","listenersCollection","_i6","_win2","_i8","_length8","_i10","_domain2","_length10","_i12","_length12","existingListener","strDomain","regexListeners","regexListener","onceFunction","errorOnClose","interval","server__typeof","runInterval","onceListener","disable","removeEventListener","cleanUpWindow","popupWindowsByWin","remoteWindows","bridge","init","initialized","addEventListener","attachEvent","initOnReady","INTERFACE"],"mappings":"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","file":"post-robot.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"postRobot\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"postRobot\"] = factory();\n\telse\n\t\troot[\"postRobot\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fce0cd39d130c49ddcd4","/* @flow */\n\nexport function isRegex(item : mixed) : boolean {\n    return Object.prototype.toString.call(item) === '[object RegExp]';\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args : Array<mixed>) {\n    // pass\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-utils/src/util.js","/* @flow */\n\nexport const PROTOCOL = {\n    MOCK:  ('mock:' : 'mock:'),\n    FILE:  ('file:' : 'file:'),\n    ABOUT: ('about:' : 'about:')\n};\n\nexport const WILDCARD = '*';\n\nexport const WINDOW_TYPE = {\n    IFRAME: ('iframe' : 'iframe'),\n    POPUP:  ('popup' : 'popup')\n};\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-utils/src/constants.js","/* @flow */\n/* eslint max-lines: 0 */\n\nimport { isRegex, noop } from './util';\nimport type { CrossDomainWindowType, SameDomainWindowType, DomainMatcher } from './types';\nimport { PROTOCOL, WILDCARD } from './constants';\n\nlet IE_WIN_ACCESS_ERROR = 'Call was rejected by callee.\\r\\n';\n\nexport function isFileProtocol(win : SameDomainWindowType = window) : boolean {\n    return win.location.protocol === PROTOCOL.FILE;\n}\n\nexport function isAboutProtocol(win : SameDomainWindowType = window) : boolean {\n    return win.location.protocol === PROTOCOL.ABOUT;\n}\n\nexport function getParent(win? : CrossDomainWindowType = window) : ?CrossDomainWindowType {\n\n    if (!win) {\n        return;\n    }\n\n    try {\n        if (win.parent && win.parent !== win) {\n            return win.parent;\n        }\n    } catch (err) {\n        // pass\n    }\n}\n\nexport function getOpener(win? : CrossDomainWindowType = window) : ?CrossDomainWindowType {\n\n    if (!win) {\n        return;\n    }\n\n    // Make sure we're not actually an iframe which has had window.open() called on us\n    if (getParent(win)) {\n        return;\n    }\n\n    try {\n        return win.opener;\n    } catch (err) {\n        // pass\n    }\n}\n\nexport function canReadFromWindow(win : CrossDomainWindowType | SameDomainWindowType) : boolean {\n    try {\n        // $FlowFixMe\n        noop(win && win.location && win.location.href);\n        return true;\n    } catch (err) {\n        // pass\n    }\n\n    return false;\n}\n\nexport function getActualDomain(win? : SameDomainWindowType = window) : string {\n\n    let location = win.location;\n\n    if (!location) {\n        throw new Error(`Can not read window location`);\n    }\n\n    let protocol = location.protocol;\n\n    if (!protocol) {\n        throw new Error(`Can not read window protocol`);\n    }\n\n    if (protocol === PROTOCOL.FILE) {\n        return `${ PROTOCOL.FILE }//`;\n    }\n\n    if (protocol === PROTOCOL.ABOUT) {\n\n        let parent = getParent(win);\n        if (parent && canReadFromWindow(parent)) {\n            // $FlowFixMe\n            return getActualDomain(parent);\n        }\n\n        return `${ PROTOCOL.ABOUT }//`;\n    }\n\n    let host = location.host;\n\n    if (!host) {\n        throw new Error(`Can not read window host`);\n    }\n\n    return `${ protocol }//${ host }`;\n}\n\nexport function getDomain(win? : SameDomainWindowType = window) : string {\n\n    let domain = getActualDomain(win);\n\n    if (domain && win.mockDomain && win.mockDomain.indexOf(PROTOCOL.MOCK) === 0) {\n        return win.mockDomain;\n    }\n\n    return domain;\n}\n\nexport function isBlankDomain(win : CrossDomainWindowType) : boolean {\n    try {\n        // $FlowFixMe\n        if (!win.location.href) {\n            return true;\n        }\n\n        if (win.location.href === 'about:blank') {\n            return true;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    return false;\n}\n\nexport function isActuallySameDomain(win : CrossDomainWindowType) : boolean {\n\n    try {\n        if (win === window) {\n            return true;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        let desc = Object.getOwnPropertyDescriptor(win, 'location');\n\n        if (desc && desc.enumerable === false) {\n            return false;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        // $FlowFixMe\n        if (isAboutProtocol(win) && canReadFromWindow(win)) {\n            return true;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        // $FlowFixMe\n        if (getActualDomain(win) === getActualDomain(window)) {\n            return true;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    return false;\n}\n\nexport function isSameDomain(win : CrossDomainWindowType | SameDomainWindowType) : boolean {\n\n    if (!isActuallySameDomain(win)) {\n        return false;\n    }\n\n    try {\n\n        if (win === window) {\n            return true;\n        }\n\n        // $FlowFixMe\n        if (isAboutProtocol(win) && canReadFromWindow(win)) {\n            return true;\n        }\n\n        // $FlowFixMe\n        if (getDomain(window) === getDomain(win)) {\n            return true;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    return false;\n}\n\n\nexport function assertSameDomain(win : CrossDomainWindowType | SameDomainWindowType) : SameDomainWindowType {\n    if (!isSameDomain(win)) {\n        throw new Error(`Expected window to be same domain`);\n    }\n\n    // $FlowFixMe\n    return win;\n}\n\nexport function getParents(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n\n    let result = [];\n\n    try {\n\n        while (win.parent !== win) {\n            result.push(win.parent);\n            win = win.parent;\n        }\n\n    } catch (err) {\n        // pass\n    }\n\n    return result;\n}\n\nexport function isAncestorParent(parent : CrossDomainWindowType, child : CrossDomainWindowType) : boolean {\n\n    if (!parent || !child) {\n        return false;\n    }\n\n    let childParent = getParent(child);\n\n    if (childParent) {\n        return childParent === parent;\n    }\n\n    if (getParents(child).indexOf(parent) !== -1) {\n        return true;\n    }\n\n    return false;\n}\n\nexport function getFrames(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n\n    let result = [];\n\n    let frames;\n\n    try {\n        frames = win.frames;\n    } catch (err) {\n        frames = win;\n    }\n\n    let len;\n\n    try {\n        len = frames.length;\n    } catch (err) {\n        // pass\n    }\n\n    if (len === 0) {\n        return result;\n    }\n\n    if (len) {\n        for (let i = 0; i < len; i++) {\n\n            let frame;\n\n            try {\n                frame = frames[i];\n            } catch (err) {\n                continue;\n            }\n\n            result.push(frame);\n        }\n\n        return result;\n    }\n\n    for (let i = 0; i < 100; i++) {\n        let frame;\n\n        try {\n            frame = frames[i];\n        } catch (err) {\n            return result;\n        }\n\n        if (!frame) {\n            return result;\n        }\n\n        result.push(frame);\n    }\n\n    return result;\n}\n\n\nexport function getAllChildFrames(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n\n    let result = [];\n\n    for (let frame of getFrames(win)) {\n        result.push(frame);\n\n        for (let childFrame of getAllChildFrames(frame)) {\n            result.push(childFrame);\n        }\n    }\n\n    return result;\n}\n\nexport function getTop(win? : CrossDomainWindowType = window) : ?CrossDomainWindowType {\n\n    try {\n        if (win.top) {\n            return win.top;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    if (getParent(win) === win) {\n        return win;\n    }\n\n    try {\n        if (isAncestorParent(window, win) && window.top) {\n            return window.top;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        if (isAncestorParent(win, window) && window.top) {\n            return window.top;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    for (let frame of getAllChildFrames(win)) {\n        try {\n            if (frame.top) {\n                return frame.top;\n            }\n        } catch (err) {\n            // pass\n        }\n\n        if (getParent(frame) === frame) {\n            return frame;\n        }\n    }\n}\n\nexport function getNextOpener(win? : CrossDomainWindowType = window) : ?CrossDomainWindowType {\n    return getOpener(getTop(win) || win);\n}\n\nexport function getUltimateTop(win? : CrossDomainWindowType = window) : CrossDomainWindowType {\n    let opener = getNextOpener(win);\n\n    if (opener) {\n        return getUltimateTop(opener);\n    }\n\n    return top;\n}\n\nexport function getAllFramesInWindow(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n    let top = getTop(win);\n\n    if (!top) {\n        throw new Error(`Can not determine top window`);\n    }\n\n    return [ ...getAllChildFrames(top), top ];\n}\n\nexport function getAllWindows(win? : CrossDomainWindowType = window) : $ReadOnlyArray<CrossDomainWindowType> {\n    let frames = getAllFramesInWindow(win);\n    let opener = getNextOpener(win);\n\n    if (opener) {\n        return [ ...getAllWindows(opener), ...frames ];\n    } else {\n        return frames;\n    }\n}\n\nexport function isTop(win : CrossDomainWindowType) : boolean {\n    return win === getTop(win);\n}\n\nexport function isFrameWindowClosed(frame : HTMLIFrameElement) : boolean {\n\n    if (!frame.contentWindow) {\n        return true;\n    }\n\n    if (!frame.parentNode) {\n        return true;\n    }\n\n    let doc = frame.ownerDocument;\n\n    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction safeIndexOf<T>(collection : Array<T>, item : T) : number {\n    for (let i = 0; i < collection.length; i++) {\n\n        try {\n            if (collection[i] === item) {\n                return i;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    return -1;\n}\n\nlet iframeWindows = [];\nlet iframeFrames = [];\n\nexport function isWindowClosed(win : CrossDomainWindowType, allowMock : boolean = true) : boolean {\n\n    try {\n        if (win === window) {\n            return false;\n        }\n    } catch (err) {\n        return true;\n    }\n\n    try {\n        if (!win) {\n            return true;\n        }\n\n    } catch (err) {\n        return true;\n    }\n\n    try {\n        if (win.closed) {\n            return true;\n        }\n\n    } catch (err) {\n\n        // I love you so much IE\n\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return false;\n        }\n\n        return true;\n    }\n\n\n    if (allowMock && isSameDomain(win)) {\n        try {\n            // $FlowFixMe\n            if (win.mockclosed) {\n                return true;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    // Mobile safari\n\n    try {\n        if (!win.parent || !win.top) {\n            return true;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    // Yes, this actually happens in IE. win === win errors out when the window\n    // is from an iframe, and the iframe was removed from the page.\n\n    try {\n        noop(win === win); // eslint-disable-line no-self-compare\n    } catch (err) {\n        return true;\n    }\n\n    // IE orphaned frame\n\n    let iframeIndex = safeIndexOf(iframeWindows, win);\n\n    if (iframeIndex !== -1) {\n        let frame = iframeFrames[iframeIndex];\n\n        if (frame && isFrameWindowClosed(frame)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction cleanIframes() {\n    for (let i = 0; i < iframeWindows.length; i++) {\n        let closed = false;\n\n        try {\n            closed = iframeWindows[i].closed;\n        } catch (err) {\n            // pass\n        }\n\n        if (closed) {\n            iframeFrames.splice(i, 1);\n            iframeWindows.splice(i, 1);\n        }\n    }\n}\n\nexport function linkFrameWindow(frame : HTMLIFrameElement) {\n\n    cleanIframes();\n\n    if (frame && frame.contentWindow) {\n        try {\n            iframeWindows.push(frame.contentWindow);\n            iframeFrames.push(frame);\n        } catch (err) {\n            // pass\n        }\n    }\n}\n\nexport function getUserAgent(win : ?SameDomainWindowType) : string {\n    win = win || window;\n    return win.navigator.mockUserAgent || win.navigator.userAgent;\n}\n\n\nexport function getFrameByName(win : CrossDomainWindowType, name : string) : ?CrossDomainWindowType {\n\n    let winFrames = getFrames(win);\n\n    for (let childFrame of winFrames) {\n        try {\n            // $FlowFixMe\n            if (isSameDomain(childFrame) && childFrame.name === name && winFrames.indexOf(childFrame) !== -1) {\n                return childFrame;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    try {\n        // $FlowFixMe\n        if (winFrames.indexOf(win.frames[name]) !== -1) {\n            // $FlowFixMe\n            return win.frames[name];\n        }\n    } catch (err) {\n        // pass\n    }\n\n    try {\n        if (winFrames.indexOf(win[name]) !== -1) {\n            return win[name];\n        }\n    } catch (err) {\n        // pass\n    }\n}\n\nexport function findChildFrameByName(win : CrossDomainWindowType, name : string) : ?CrossDomainWindowType {\n\n    let frame = getFrameByName(win, name);\n\n    if (frame) {\n        return frame;\n    }\n\n    for (let childFrame of getFrames(win)) {\n        let namedFrame = findChildFrameByName(childFrame, name);\n\n        if (namedFrame) {\n            return namedFrame;\n        }\n    }\n}\n\nexport function findFrameByName(win : CrossDomainWindowType, name : string) : ?CrossDomainWindowType {\n\n    let frame;\n\n    frame = getFrameByName(win, name);\n\n    if (frame) {\n        return frame;\n    }\n\n    let top = getTop(win) || win;\n\n    return findChildFrameByName(top, name);\n}\n\nexport function isParent(win : CrossDomainWindowType, frame : CrossDomainWindowType) : boolean {\n\n    let frameParent = getParent(frame);\n\n    if (frameParent) {\n        return frameParent === win;\n    }\n\n    for (let childFrame of getFrames(win)) {\n        if (childFrame === frame) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function isOpener(parent : CrossDomainWindowType, child : CrossDomainWindowType) : boolean {\n\n    return parent === getOpener(child);\n}\n\nexport function getAncestor(win? : CrossDomainWindowType = window) : ?CrossDomainWindowType {\n    win = win || window;\n\n    let opener = getOpener(win);\n\n    if (opener) {\n        return opener;\n    }\n\n    let parent = getParent(win);\n\n    if (parent) {\n        return parent;\n    }\n}\n\nexport function getAncestors(win : CrossDomainWindowType) : Array<CrossDomainWindowType> {\n\n    let results = [];\n\n    let ancestor = win;\n\n    while (ancestor) {\n        ancestor = getAncestor(ancestor);\n        if (ancestor) {\n            results.push(ancestor);\n        }\n    }\n\n    return results;\n}\n\n\nexport function isAncestor(parent : CrossDomainWindowType, child : CrossDomainWindowType) : boolean {\n\n    let actualParent = getAncestor(child);\n\n    if (actualParent) {\n        if (actualParent === parent) {\n            return true;\n        }\n\n        return false;\n    }\n\n    if (child === parent) {\n        return false;\n    }\n\n    if (getTop(child) === child) {\n        return false;\n    }\n\n    for (let frame of getFrames(parent)) {\n        if (frame === child) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function isPopup(win? : CrossDomainWindowType = window) : boolean {\n    return Boolean(getOpener(win));\n}\n\nexport function isIframe(win? : CrossDomainWindowType = window) : boolean {\n    return Boolean(getParent(win));\n}\n\nexport function isFullpage(win? : CrossDomainWindowType = window) : boolean {\n    return Boolean(!isIframe(win) && !isPopup(win));\n}\n\nfunction anyMatch(collection1, collection2) : boolean {\n\n    for (let item1 of collection1) {\n        for (let item2 of collection2) {\n            if (item1 === item2) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nexport function getDistanceFromTop(win : CrossDomainWindowType = window) : number {\n    let distance = 0;\n    let parent = win;\n\n    while (parent) {\n        parent = getParent(parent);\n        if (parent) {\n            distance += 1;\n        }\n    }\n\n    return distance;\n}\n\nexport function getNthParent(win : CrossDomainWindowType, n : number = 1) : ?CrossDomainWindowType {\n    let parent = win;\n\n    for (let i = 0; i < n; i++) {\n        if (!parent) {\n            return;\n        }\n\n        parent = getParent(parent);\n    }\n\n    return parent;\n}\n\nexport function getNthParentFromTop(win : CrossDomainWindowType, n : number = 1) : ?CrossDomainWindowType {\n    return getNthParent(win, getDistanceFromTop(win) - n);\n}\n\nexport function isSameTopWindow(win1 : CrossDomainWindowType, win2 : CrossDomainWindowType) : boolean {\n\n    let top1 = getTop(win1) || win1;\n    let top2 = getTop(win2) || win2;\n\n    try {\n        if (top1 && top2) {\n            if (top1 === top2) {\n                return true;\n            }\n\n            return false;\n        }\n    } catch (err) {\n        // pass\n    }\n\n    let allFrames1 = getAllFramesInWindow(win1);\n    let allFrames2 = getAllFramesInWindow(win2);\n\n    if (anyMatch(allFrames1, allFrames2)) {\n        return true;\n    }\n\n    let opener1 = getOpener(top1);\n    let opener2 = getOpener(top2);\n\n    if (opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2)) {\n        return false;\n    }\n\n    if (opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1)) {\n        return false;\n    }\n\n    return false;\n}\n\nexport function matchDomain(pattern : DomainMatcher, origin : DomainMatcher) : boolean {\n\n    if (typeof pattern === 'string') {\n\n        if (typeof origin === 'string') {\n            return pattern === WILDCARD || origin === pattern;\n        }\n\n        if (isRegex(origin)) {\n            return false;\n        }\n\n        if (Array.isArray(origin)) {\n            return false;\n        }\n    }\n\n    if (isRegex(pattern)) {\n\n        if (isRegex(origin)) {\n            return pattern.toString() === origin.toString();\n        }\n\n        if (Array.isArray(origin)) {\n            return false;\n        }\n\n        // $FlowFixMe\n        return Boolean(origin.match(pattern));\n    }\n\n    if (Array.isArray(pattern)) {\n\n        if (Array.isArray(origin)) {\n            return JSON.stringify(pattern) === JSON.stringify(origin);\n        }\n\n        if (isRegex(origin)) {\n            return false;\n        }\n\n        return pattern.some(subpattern => matchDomain(subpattern, origin));\n    }\n\n    return false;\n}\n\nexport function stringifyDomainPattern(pattern : DomainMatcher) : string {\n    if (Array.isArray(pattern)) {\n        return `(${ pattern.join(' | ') })`;\n    } else if (isRegex(pattern)) {\n        return `RegExp(${ pattern.toString() }`;\n    } else {\n        return pattern.toString();\n    }\n}\n\nexport function getDomainFromUrl(url : string) : string {\n\n    let domain;\n\n    if (url.match(/^(https?|mock|file):\\/\\//)) {\n        domain = url;\n    } else {\n        return getDomain();\n    }\n\n    domain = domain.split('/').slice(0, 3).join('/');\n\n    return domain;\n}\n\nexport function onCloseWindow(win : CrossDomainWindowType, callback : Function, delay : number = 1000, maxtime : number = Infinity) : { cancel : () => void } {\n\n    let timeout;\n\n    let check = () => {\n\n        if (isWindowClosed(win)) {\n\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n\n            return callback();\n        }\n\n        if (maxtime <= 0) {\n            clearTimeout(timeout);\n        } else {\n            maxtime -= delay;\n            timeout = setTimeout(check, delay);\n        }\n    };\n\n    check();\n\n    return {\n        cancel() {\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n        }\n    };\n}\n\n// eslint-disable-next-line complexity\nexport function isWindow(obj : Object) : boolean {\n\n    try {\n        if (obj === window) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (Object.prototype.toString.call(obj) === '[object Window]') {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (window.Window && obj instanceof window.Window) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (obj && obj.self === obj) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (obj && obj.parent === obj) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (obj && obj.top === obj) {\n            return true;\n        }\n    } catch (err) {\n        if (err && err.message === IE_WIN_ACCESS_ERROR) {\n            return true;\n        }\n    }\n\n    try {\n        if (noop(obj === obj) === '__unlikely_value__') { // eslint-disable-line no-self-compare\n            return false;\n        }\n\n    } catch (err) {\n        return true;\n    }\n\n    try {\n        if (obj && obj.__cross_domain_utils_window_check__ === '__unlikely_value__') {\n            return false;\n        }\n\n    } catch (err) {\n        return true;\n    }\n\n    return false;\n}\n\nexport function isBrowser() : boolean {\n    return (typeof window !== 'undefined' && typeof window.location !== 'undefined');\n}\n\nexport function isCurrentDomain(domain : string) : boolean {\n    if (!isBrowser()) {\n        return false;\n    }\n\n    return (getDomain() === domain);\n}\n\nexport function isMockDomain(domain : string) : boolean {\n    return domain.indexOf(PROTOCOL.MOCK) === 0;\n}\n\nexport function normalizeMockUrl(url : string) : string {\n    if (!isMockDomain(getDomainFromUrl(url))) {\n        return url;\n    }\n\n    if (!__TEST__) {\n        throw new Error(`Mock urls not supported out of test mode`);\n    }\n\n    return url.replace(/^mock:\\/\\/[^/]+/, getActualDomain(window));\n}\n\nexport function closeWindow(win : CrossDomainWindowType) {\n    try {\n        win.close();\n    } catch (err) {\n        // pass\n    }\n}\n\nexport function getFrameForWindow(win : CrossDomainWindowType) : ?HTMLElement {\n    if (isSameDomain(win)) {\n        return assertSameDomain(win).frameElement;\n    }\n\n    for (const frame of document.querySelectorAll('iframe')) {\n        if (frame && frame.contentWindow && frame.contentWindow === win) {\n            return frame;\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-utils/src/utils.js","/* @flow */\n\nexport function safeIndexOf<T>(collection : Array<T>, item : T) : number {\n    for (let i = 0; i < collection.length; i++) {\n\n        try {\n            if (collection[i] === item) {\n                return i;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    return -1;\n}\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args : Array<mixed>) {\n    // pass\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-safe-weakmap/src/util.js","/* @flow */\n\nimport { isWindow, isWindowClosed } from 'cross-domain-utils/src';\n\nimport { hasNativeWeakMap } from './native';\nimport { noop, safeIndexOf } from './util';\n\nexport class CrossDomainSafeWeakMap<K : Object, V : mixed> {\n\n    name : string\n    weakmap : ?WeakMap<K, V>\n    keys : Array<K>\n    values : Array<V>\n\n    constructor() {\n        // eslint-disable-next-line no-bitwise\n        this.name = `__weakmap_${ Math.random() * 1e9 >>> 0 }__`;\n\n        if (hasNativeWeakMap()) {\n            try {\n                this.weakmap = new WeakMap();\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this.keys  = [];\n        this.values = [];\n    }\n\n    _cleanupClosedWindows() {\n\n        let weakmap = this.weakmap;\n        let keys = this.keys;\n\n        for (let i = 0; i < keys.length; i++) {\n            let value = keys[i];\n\n            if (isWindow(value) && isWindowClosed(value)) {\n\n                if (weakmap) {\n                    try {\n                        weakmap.delete(value);\n                    } catch (err) {\n                        // pass\n                    }\n                }\n\n                keys.splice(i, 1);\n                this.values.splice(i, 1);\n\n                i -= 1;\n            }\n        }\n    }\n\n    isSafeToReadWrite(key : K) : boolean {\n\n        if (isWindow(key)) {\n            return false;\n        }\n\n        try {\n            noop(key && key.self);\n            noop(key && key[this.name]);\n        } catch (err) {\n            return false;\n        }\n\n        return true;\n    }\n\n    set(key : K, value : V) {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        let weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.set(key, value);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                let name = this.name;\n                let entry = key[name];\n\n                if (entry && entry[0] === key) {\n                    entry[1] = value;\n                } else {\n                    Object.defineProperty(key, name, {\n                        value:    [ key, value ],\n                        writable: true\n                    });\n                }\n\n                return;\n\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        let keys = this.keys;\n        let values = this.values;\n        let index = safeIndexOf(keys, key);\n\n        if (index === -1) {\n            keys.push(key);\n            values.push(value);\n        } else {\n            values[index] = value;\n        }\n    }\n\n    get(key : K) : V | void {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        let weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return weakmap.get(key);\n                }\n                \n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                let entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    return entry[1];\n                }\n\n                return;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        let keys = this.keys;\n        let index = safeIndexOf(keys, key);\n\n        if (index === -1) {\n            return;\n        }\n\n        return this.values[index];\n    }\n\n    delete(key : K) {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        let weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.delete(key);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                let entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    entry[0] = entry[1] = undefined;\n                }\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        let keys = this.keys;\n        let index = safeIndexOf(keys, key);\n\n        if (index !== -1) {\n            keys.splice(index, 1);\n            this.values.splice(index, 1);\n        }\n    }\n\n    has(key : K) : boolean {\n\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        let weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return true;\n                }\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                let entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    return true;\n                }\n\n                return false;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        let index = safeIndexOf(this.keys, key);\n        return index !== -1;\n    }\n\n    getOrSet(key : K, getter : () => V) : V {\n        if (this.has(key)) {\n            // $FlowFixMe\n            return this.get(key);\n        }\n\n        let value = getter();\n        this.set(key, value);\n        return value;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-safe-weakmap/src/weakmap.js","/* @flow */\n\nexport function hasNativeWeakMap() : boolean {\n\n    if (typeof WeakMap === 'undefined') {\n        return false;\n    }\n\n    if (typeof Object.freeze === 'undefined') {\n        return false;\n    }\n\n    try {\n\n        let testWeakMap = new WeakMap();\n        let testKey = {};\n        let testValue = '__testvalue__';\n\n        Object.freeze(testKey);\n\n        testWeakMap.set(testKey, testValue);\n\n        if (testWeakMap.get(testKey) === testValue) {\n            return true;\n        }\n\n        return false;\n\n    } catch (err) {\n\n        return false;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/cross-domain-safe-weakmap/src/native.js","/* @flow */\n\nexport let CONSTANTS = {\n\n    POST_MESSAGE_TYPE: {\n        REQUEST:  'postrobot_message_request',\n        RESPONSE: 'postrobot_message_response',\n        ACK:      'postrobot_message_ack'\n    },\n\n    POST_MESSAGE_ACK: {\n        SUCCESS: 'success',\n        ERROR:   'error'\n    },\n\n    POST_MESSAGE_NAMES: {\n        METHOD:      'postrobot_method',\n        HELLO:       'postrobot_ready',\n        OPEN_TUNNEL: 'postrobot_open_tunnel'\n    },\n\n    WINDOW_TYPES: {\n        FULLPAGE: 'fullpage',\n        POPUP:    'popup',\n        IFRAME:   'iframe'\n    },\n\n    WINDOW_PROPS: {\n        POSTROBOT: '__postRobot__'\n    },\n\n    SERIALIZATION_TYPES: {\n        METHOD:        'postrobot_method',\n        ERROR:         'postrobot_error',\n        PROMISE:       'postrobot_promise',\n        ZALGO_PROMISE: 'postrobot_zalgo_promise',\n        REGEX:         'regex'\n    },\n\n    SEND_STRATEGIES: {\n        POST_MESSAGE: 'postrobot_post_message',\n        BRIDGE:       'postrobot_bridge',\n        GLOBAL:       'postrobot_global'\n    },\n\n    MOCK_PROTOCOL: 'mock:',\n    FILE_PROTOCOL: 'file:',\n\n    BRIDGE_NAME_PREFIX: '__postrobot_bridge__',\n    POSTROBOT_PROXY:    '__postrobot_proxy__',\n\n    WILDCARD: '*'\n};\n\nexport const POST_MESSAGE_NAMES = {\n    METHOD:      'postrobot_method',\n    HELLO:       'postrobot_hello',\n    OPEN_TUNNEL: 'postrobot_open_tunnel'\n};\n\nexport let POST_MESSAGE_NAMES_LIST : Array<string> = Object.keys(POST_MESSAGE_NAMES)\n    .map(key => POST_MESSAGE_NAMES[key]);\n\n\n\n// WEBPACK FOOTER //\n// ./src/conf/constants.js","/* @flow */\n\nimport { CONSTANTS } from './constants';\n\nexport let CONFIG : Object = {\n\n    ALLOW_POSTMESSAGE_POPUP: ('__ALLOW_POSTMESSAGE_POPUP__' in window)\n        ? window.__ALLOW_POSTMESSAGE_POPUP__\n        : __POST_ROBOT__.__ALLOW_POSTMESSAGE_POPUP__,\n\n    BRIDGE_TIMEOUT:       5000,\n    CHILD_WINDOW_TIMEOUT: 5000,\n\n    ACK_TIMEOUT: (window.navigator.userAgent.match(/MSIE/i) !== -1 && !__TEST__) ? 10000 : 2000,\n    RES_TIMEOUT: __TEST__ ? 2000 : -1,\n    \n    ALLOWED_POST_MESSAGE_METHODS: {\n        [ CONSTANTS.SEND_STRATEGIES.POST_MESSAGE ]: true,\n        [ CONSTANTS.SEND_STRATEGIES.BRIDGE ]:       true,\n        [ CONSTANTS.SEND_STRATEGIES.GLOBAL ]:       true\n    },\n\n    ALLOW_SAME_ORIGIN: false\n};\n\nif (window.location.href.indexOf(CONSTANTS.FILE_PROTOCOL) === 0) {\n    CONFIG.ALLOW_POSTMESSAGE_POPUP = true;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/conf/config.js","/* @flow */\n\nimport { WeakMap } from 'cross-domain-safe-weakmap/src';\nimport { isPopup, isIframe, getUserAgent } from 'cross-domain-utils/src';\n\nimport { CONFIG, CONSTANTS } from '../conf';\n\n\nexport function stringifyError(err : mixed, level : number = 1) : string {\n\n    if (level >= 3) {\n        return 'stringifyError stack overflow';\n    }\n\n    try {\n        if (!err) {\n            return `<unknown error: ${ Object.prototype.toString.call(err) }>`;\n        }\n\n        if (typeof err === 'string') {\n            return err;\n        }\n\n        if (err instanceof Error) {\n            let stack = err && err.stack;\n            let message = err && err.message;\n\n            if (stack && message) {\n                if (stack.indexOf(message) !== -1) {\n                    return stack;\n                } else {\n                    return `${ message }\\n${ stack }`;\n                }\n            } else if (stack) {\n                return stack;\n            } else if (message) {\n                return message;\n            }\n        }\n\n        if (typeof err.toString === 'function') {\n            return err.toString();\n        }\n\n        return Object.prototype.toString.call(err);\n\n    } catch (newErr) { // eslint-disable-line unicorn/catch-error-name\n        return `Error while stringifying error: ${ stringifyError(newErr, level + 1) }`;\n    }\n}\n\n// eslint-disable-next-line flowtype/no-weak-types\nexport let once = <T>(method : Function) : ((...args : Array<any>) => T | void) => {\n    if (!method) {\n        return method;\n    }\n    let called = false;\n    return function onceWrapper() : T | void {\n        if (!called) {\n            called = true;\n            return method.apply(this, arguments);\n        }\n    };\n};\n\n// eslint-disable-next-line no-unused-vars\nexport function noop(...args : Array<mixed>) {\n    // pass\n}\n\nexport function addEventListener(obj : Object, event : string, handler : Function) : { cancel : () => void } {\n    if (obj.addEventListener) {\n        obj.addEventListener(event, handler);\n    } else {\n        obj.attachEvent(`on${ event }`, handler);\n    }\n\n    return {\n        cancel() {\n            if (obj.removeEventListener) {\n                obj.removeEventListener(event, handler);\n            } else {\n                obj.detachEvent(`on${ event }`, handler);\n            }\n        }\n    };\n}\n\nexport function uniqueID() : string {\n\n    let chars = '0123456789abcdef';\n\n    return 'xxxxxxxxxx'.replace(/./g, () => {\n        return chars.charAt(Math.floor(Math.random() * chars.length));\n    });\n}\n\ntype MixedArrayType = Array<mixed>;\n\nexport function eachArray(item : MixedArrayType, callback : (item : mixed, key : number) => mixed) {\n    for (let i = 0; i < item.length; i++) {\n        callback(item[i], i);\n    }\n}\n\nexport function eachObject(item : Object, callback : (item : mixed, key : string) => mixed) {\n    for (let key in item) {\n        if (item.hasOwnProperty(key)) {\n            callback(item[key], key);\n        }\n    }\n}\n\nexport function each<T : Object | MixedArrayType>(item : T, callback : (item : mixed, key : number | string) => mixed) {\n    if (Array.isArray(item)) {\n        eachArray(item, callback);\n    } else if (typeof item === 'object' && item !== null) {\n        eachObject(item, callback);\n    }\n}\n\nexport function replaceObject<T : Object | MixedArrayType>(item : T, callback : (item : mixed, key : number | string) => mixed, depth : number = 1) : T {\n\n    if (depth >= 100) {\n        throw new Error(`Self-referential object passed, or object contained too many layers`);\n    }\n\n    let newobj;\n\n    if (typeof item === 'object' && item !== null && !Array.isArray(item)) {\n        newobj = {};\n    } else if (Array.isArray(item)) {\n        newobj = [];\n    } else {\n        throw new TypeError(`Invalid type: ${ typeof item }`);\n    }\n\n    each(item, (childItem, key) => {\n\n        let result = callback(childItem, key);\n\n        if (typeof result !== 'undefined') {\n            // $FlowFixMe\n            newobj[key] = result;\n        } else if (typeof childItem === 'object' && childItem !== null) {\n            // $FlowFixMe\n            newobj[key] = replaceObject(childItem, callback, depth + 1);\n        } else {\n            // $FlowFixMe\n            newobj[key] = childItem;\n        }\n    });\n\n    // $FlowFixMe\n    return newobj;\n}\n\nexport function safeInterval(method : Function, time : number) : { cancel : () => void } {\n    let timeout;\n\n    function runInterval() {\n        timeout = setTimeout(runInterval, time);\n        method.call();\n    }\n\n    timeout = setTimeout(runInterval, time);\n\n    return {\n        cancel() {\n            clearTimeout(timeout);\n        }\n    };\n}\n\nexport function isRegex(item : mixed) : boolean {\n    return Object.prototype.toString.call(item) === '[object RegExp]';\n}\n\n\ntype FunctionProxy<T : Function> = (method : T) => T;\n\n// eslint-disable-next-line flowtype/no-weak-types\nexport let weakMapMemoize : FunctionProxy<*> = <R : mixed>(method : (arg : any) => R) : ((...args : Array<any>) => R) => {\n\n    let weakmap = new WeakMap();\n\n    // eslint-disable-next-line flowtype/no-weak-types\n    return function weakmapMemoized(arg : any) : R {\n        let result = weakmap.get(arg);\n\n        if (typeof result !== 'undefined') {\n            return result;\n        }\n\n        result = method.call(this, arg);\n\n        if (typeof result !== 'undefined') {\n            weakmap.set(arg, result);\n        }\n\n        return result;\n    };\n};\n\nexport function getWindowType() : string {\n    if (isPopup()) {\n        return CONSTANTS.WINDOW_TYPES.POPUP;\n    }\n    if (isIframe()) {\n        return CONSTANTS.WINDOW_TYPES.IFRAME;\n    }\n    return CONSTANTS.WINDOW_TYPES.FULLPAGE;\n}\n\nexport function jsonStringify<T : mixed>(obj : T, replacer : ?Function, indent : number | void) : string {\n\n    let objectToJSON;\n    let arrayToJSON;\n\n    try {\n        if (JSON.stringify({}) !== '{}') {\n            // $FlowFixMe\n            objectToJSON = Object.prototype.toJSON;\n            // $FlowFixMe\n            delete Object.prototype.toJSON;\n        }\n\n        if (JSON.stringify({}) !== '{}') {\n            throw new Error(`Can not correctly serialize JSON objects`);\n        }\n\n        if (JSON.stringify([]) !== '[]') {\n            // $FlowFixMe\n            arrayToJSON  = Array.prototype.toJSON;\n            // $FlowFixMe\n            delete Array.prototype.toJSON;\n        }\n\n        if (JSON.stringify([]) !== '[]') {\n            throw new Error(`Can not correctly serialize JSON objects`);\n        }\n\n    } catch (err) {\n        throw new Error(`Can not repair JSON.stringify: ${ err.message }`);\n    }\n\n    let result = JSON.stringify.call(this, obj, replacer, indent);\n\n    try {\n        if (objectToJSON) {\n            // $FlowFixMe\n            Object.prototype.toJSON = objectToJSON; // eslint-disable-line no-extend-native\n        }\n\n        if (arrayToJSON) {\n            // $FlowFixMe\n            Array.prototype.toJSON = arrayToJSON; // eslint-disable-line no-extend-native\n        }\n\n    } catch (err) {\n        throw new Error(`Can not repair JSON.stringify: ${ err.message }`);\n    }\n\n\n    return result;\n}\n\nexport function jsonParse(item : string) : mixed {\n    return JSON.parse(item);\n}\n            \nexport function needsGlobalMessagingForBrowser() : boolean {\n\n    if (getUserAgent(window).match(/MSIE|trident|edge\\/12|edge\\/13/i)) {\n        return true;\n    }\n        \n    if (!CONFIG.ALLOW_POSTMESSAGE_POPUP) {\n        return true;\n    }\n        \n    return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/util.js","/* @flow */\n\nexport function isPromise(item : mixed) : boolean {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (typeof Promise !== 'undefined' && item instanceof Promise) {\n            return true;\n        }\n\n        if (typeof window !== 'undefined' && typeof window.Window === 'function' && item instanceof window.Window) {\n            return false;\n        }\n\n        if (typeof window !== 'undefined' && typeof window.constructor === 'function' && item instanceof window.constructor) {\n            return false;\n        }\n\n        let toString = ({}).toString;\n\n        if (toString) {\n            let name = toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/utils.js","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\nconst dispatchedErrors = [];\nconst possiblyUnhandledPromiseHandlers : Array<(mixed, promise? : ZalgoPromise<mixed>) => void> = [];\n\nexport function dispatchPossiblyUnhandledError<T>(err : mixed, promise : ZalgoPromise<T>) {\n\n    if (dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    dispatchedErrors.push(err);\n\n    setTimeout(() => {\n        if (__DEBUG__) {\n            // $FlowFixMe\n            throw new Error(`${ err.stack || err.toString() }\\n\\nFrom promise:\\n\\n${ promise.stack }`);\n        }\n\n        throw err;\n    }, 1);\n\n    for (let j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) {\n        // $FlowFixMe\n        possiblyUnhandledPromiseHandlers[j](err, promise);\n    }\n}\n\nexport function onPossiblyUnhandledException(handler : (mixed, promise? : ZalgoPromise<mixed>) => void) : { cancel : () => void } {\n    possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel() {\n            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/exceptions.js","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\nlet activeCount = 0;\nlet flushPromise;\n\nfunction flushActive() {\n    if (!activeCount && flushPromise) {\n        const promise = flushPromise;\n        flushPromise = null;\n        promise.resolve();\n    }\n}\n\nexport function startActive() {\n    activeCount += 1;\n}\n\nexport function endActive() {\n    activeCount -= 1;\n    flushActive();\n}\n\nexport function awaitActive(Zalgo : Class<ZalgoPromise<*>>) : ZalgoPromise<void> { // eslint-disable-line no-undef\n    let promise = flushPromise = flushPromise || new Zalgo();\n    flushActive();\n    return promise;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/flush.js","/* @flow */\n\nimport { isPromise } from './utils';\nimport { onPossiblyUnhandledException, dispatchPossiblyUnhandledError } from './exceptions';\nimport { startActive, endActive, awaitActive } from './flush';\n\nexport class ZalgoPromise<R : mixed> {\n\n    resolved : boolean\n    rejected : boolean\n    errorHandled : boolean\n    value : R\n    error : mixed\n    handlers : Array<{\n        promise : ZalgoPromise<*>,\n        onSuccess : void | (result : R) => mixed,\n        onError : void | (error : mixed) => mixed\n    }>\n    dispatching : boolean\n    stack : string\n\n    constructor(handler : ?(resolve : (result : R) => void, reject : (error : mixed) => void) => void) {\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            let result;\n            let error;\n            let resolved = false;\n            let rejected = false;\n            let isAsync = false;\n\n            startActive();\n\n            try {\n                handler(res => {\n                    if (isAsync) {\n                        this.resolve(res);\n                    } else {\n                        resolved = true;\n                        result = res;\n                    }\n\n                }, err => {\n                    if (isAsync) {\n                        this.reject(err);\n                    } else {\n                        rejected = true;\n                        error = err;\n                    }\n                });\n\n            } catch (err) {\n                endActive();\n                this.reject(err);\n                return;\n            }\n\n            endActive();\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(result);\n            } else if (rejected) {\n                this.reject(error);\n            }\n        }\n\n        if (__DEBUG__) {\n            try {\n                throw new Error(`ZalgoPromise`);\n            } catch (err) {\n                this.stack = err.stack;\n            }\n        }\n    }\n\n    resolve(result : R) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    }\n\n    reject(error : mixed) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            // $FlowFixMe\n            let err = (error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error));\n            error = new Error(`Expected reject to be called with Error, got ${ err }`);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(() => {\n                if (!this.errorHandled) {\n                    dispatchPossiblyUnhandledError(error, this);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    }\n\n    asyncReject(error : mixed) : ZalgoPromise<R> {\n        this.errorHandled = true;\n        this.reject(error);\n        return this;\n    }\n    \n    dispatch() {\n\n        let { dispatching, resolved, rejected, handlers } = this;\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        startActive();\n\n        const chain = <T>(firstPromise : ZalgoPromise<T>, secondPromise : ZalgoPromise<T>) => {\n            return firstPromise.then(res => {\n                secondPromise.resolve(res);\n            }, err => {\n                secondPromise.reject(err);\n            });\n        };\n\n        for (let i = 0; i < handlers.length; i++) {\n\n            let { onSuccess, onError, promise } = handlers[i];\n\n            let result;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(this.value) : this.value;\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(this.error);\n                    continue;\n                }\n\n                try {\n                    result = onError(this.error);\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n\n                if (result.resolved) {\n                    promise.resolve(result.value);\n                } else {\n                    promise.reject(result.error);\n                }\n\n                result.errorHandled = true;\n\n            } else if (isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n\n                } else {\n                    // $FlowFixMe\n                    chain(result, promise);\n                }\n\n            } else {\n\n                promise.resolve(result);\n            }\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        endActive();\n    }\n\n    then<X : mixed, Y : mixed>(onSuccess : void | (result : R) => (ZalgoPromise<X> | Y), onError : void | (error : mixed) => (ZalgoPromise<X> | Y)) : ZalgoPromise<X | Y> {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        let promise : ZalgoPromise<X | Y> = new ZalgoPromise();\n\n        this.handlers.push({\n            promise,\n            onSuccess,\n            onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    }\n\n    catch<X : mixed, Y : mixed>(onError : (error : mixed) => ZalgoPromise<X> | Y) : ZalgoPromise<X | Y> {\n        return this.then(undefined, onError);\n    }\n\n    finally(onFinally : () => mixed) : ZalgoPromise<R> {\n\n        if (onFinally && typeof onFinally !== 'function' && !onFinally.call) {\n            throw new Error('Promise.finally expected a function');\n        }\n\n        return this.then((result) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    return result;\n                });\n        }, (err) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    throw err;\n                });\n        });\n    }\n\n    timeout(time : number, err : ?Error) : ZalgoPromise<R> {\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        let timeout = setTimeout(() => {\n\n            if (this.resolved || this.rejected) {\n                return;\n            }\n\n            this.reject(err || new Error(`Promise timed out after ${ time }ms`));\n\n        }, time);\n\n        return this.then(result => {\n            clearTimeout(timeout);\n            return result;\n        });\n    }\n\n    // $FlowFixMe\n    toPromise() : Promise<R> {\n        // $FlowFixMe\n        if (typeof Promise === 'undefined') {\n            throw new TypeError(`Could not find Promise`);\n        }\n        // $FlowFixMe\n        return Promise.resolve(this); // eslint-disable-line compat/compat\n    }\n\n    static resolve<X : mixed>(value : X | ZalgoPromise<X>) : ZalgoPromise<X> {\n\n        if (value instanceof ZalgoPromise) {\n            return value;\n        }\n\n        if (isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise((resolve, reject) => value.then(resolve, reject));\n        }\n\n        return new ZalgoPromise().resolve(value);\n    }\n\n    static reject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().reject(error);\n    }\n\n    static asyncReject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().asyncReject(error);\n    }\n\n    static all<X : Array<mixed>>(promises : X) : ZalgoPromise<$TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n\n        let promise = new ZalgoPromise();\n        let count = promises.length;\n        let results = [];\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        const chain = <T>(i : number, firstPromise : ZalgoPromise<T>, secondPromise : ZalgoPromise<T>) => {\n            return firstPromise.then(res => {\n                results[i] = res;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, err => {\n                secondPromise.reject(err);\n            });\n        };\n\n        for (let i = 0; i < promises.length; i++) {\n            let prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    continue;\n                }\n            } else if (!isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                continue;\n            }\n\n            chain(i, ZalgoPromise.resolve(prom), promise);\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    }\n\n    static hash<O : Object>(promises : O) : ZalgoPromise<$ObjMap<O, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n        let result = {};\n        \n        return ZalgoPromise.all(Object.keys(promises).map(key => {\n            return ZalgoPromise.resolve(promises[key]).then(value => {\n                result[key] = value;\n            });\n        })).then(() => {\n            return result;\n        });\n    }\n\n    static map<T, X>(items : Array<T>, method : (T) => (ZalgoPromise<X> | X)) : ZalgoPromise<Array<X>> {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    }\n\n    static onPossiblyUnhandledException(handler : (err : mixed) => void) : { cancel : () => void } {\n        return onPossiblyUnhandledException(handler);\n    }\n\n    static try<X : mixed, Y : mixed, C : mixed, A : Array<mixed>>(method : (...args : A) => (ZalgoPromise<X> | Y), context : ?C, args : ?A) : ZalgoPromise<X | Y> {\n\n        if (method && typeof method !== 'function' && !method.call) {\n            throw new Error('Promise.try expected a function');\n        }\n\n        let result;\n\n        startActive();\n        \n        try {\n            // $FlowFixMe\n            result = method.apply(context, args || []);\n        } catch (err) {\n            endActive();\n            return ZalgoPromise.reject(err);\n        }\n\n        endActive();\n\n        return ZalgoPromise.resolve(result);\n    }\n\n    static delay(delay : number) : ZalgoPromise<void> {\n        return new ZalgoPromise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    }\n\n    static isPromise(value : mixed) : boolean {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return isPromise(value);\n    }\n\n    static flush() : ZalgoPromise<void> {\n        return awaitActive(ZalgoPromise);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/zalgo-promise/src/promise.js","/* @flow */\n\nimport { CONSTANTS } from './conf';\n\nexport let global : Object = window[CONSTANTS.WINDOW_PROPS.POSTROBOT] = window[CONSTANTS.WINDOW_PROPS.POSTROBOT] || {};\n\n// Backwards compatibility\n\nglobal.registerSelf = () => {\n    // pass\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/global.js","/* @flow */\n\nimport { WeakMap } from 'cross-domain-safe-weakmap/src';\nimport { matchDomain, type CrossDomainWindowType } from 'cross-domain-utils/src';\nimport { ZalgoPromise } from 'zalgo-promise/src';\n\nimport { CONSTANTS } from '../conf';\nimport { global } from '../global';\n\nimport { once, uniqueID, replaceObject, stringifyError, isRegex } from './util';\n\nglobal.methods = global.methods || new WeakMap();\n\nexport let listenForMethods = once(() => {\n    global.on(CONSTANTS.POST_MESSAGE_NAMES.METHOD, { origin: CONSTANTS.WILDCARD }, ({ source, origin, data } : { source : CrossDomainWindowType, origin : string, data : Object }) => {\n\n        let methods = global.methods.get(source);\n\n        if (!methods) {\n            throw new Error(`Could not find any methods this window has privileges to call`);\n        }\n\n        let meth = methods[data.id];\n\n        if (!meth) {\n            throw new Error(`Could not find method with id: ${ data.id }`);\n        }\n\n        if (!matchDomain(meth.domain, origin)) {\n            throw new Error(`Method domain ${ meth.domain } does not match origin ${ origin }`);\n        }\n\n        return ZalgoPromise.try(() => {\n            return meth.method.apply({ source, origin, data }, data.args);\n\n        }).then(result => {\n\n            return {\n                result,\n                id:   data.id,\n                name: data.name\n            };\n        });\n    });\n});\n\nfunction isSerialized(item : mixed, type : string) : boolean {\n    return typeof item === 'object' && item !== null && item.__type__ === type;\n}\n\ntype SerializedMethod = {\n    __type__ : string,\n    __id__ : string,\n    __name__ : string\n};\n\nexport function serializeMethod(destination : CrossDomainWindowType, domain : string | Array<string>, method : Function, name : string) : SerializedMethod {\n\n    let id = uniqueID();\n\n    let methods = global.methods.get(destination);\n\n    if (!methods) {\n        methods = {};\n        global.methods.set(destination, methods);\n    }\n\n    methods[id] = { domain, method };\n\n    return {\n        __type__: CONSTANTS.SERIALIZATION_TYPES.METHOD,\n        __id__:   id,\n        __name__: name\n    };\n}\n\ntype SerializedError = {\n    __type__ : string,\n    __message__ : string\n};\n\nfunction serializeError(err : mixed) : SerializedError {\n    return {\n        __type__:    CONSTANTS.SERIALIZATION_TYPES.ERROR,\n        __message__: stringifyError(err),\n        // $FlowFixMe\n        __code__:    err.code\n    };\n}\n\ntype SerializePromise = {\n    __type__ : string,\n    __then__ : SerializedMethod\n};\n\nfunction serializePromise(destination : CrossDomainWindowType, domain : string | Array<string>, promise : ZalgoPromise<mixed>, name : string) : SerializePromise {\n    return {\n        __type__: CONSTANTS.SERIALIZATION_TYPES.PROMISE,\n        __then__: serializeMethod(destination, domain, (resolve, reject) => promise.then(resolve, reject), `${ name }.then`)\n    };\n}\n\nfunction serializeZalgoPromise(destination : CrossDomainWindowType, domain : string | Array<string>, promise : ZalgoPromise<mixed>, name : string) : SerializePromise {\n    return {\n        __type__: CONSTANTS.SERIALIZATION_TYPES.ZALGO_PROMISE,\n        __then__: serializeMethod(destination, domain, (resolve, reject) => promise.then(resolve, reject), `${ name }.then`)\n    };\n}\n\ntype SerializedRegex = {\n    __type__ : string,\n    __source__ : string\n};\n\nfunction serializeRegex(regex : RegExp) : SerializedRegex {\n    return {\n        __type__:   CONSTANTS.SERIALIZATION_TYPES.REGEX,\n        __source__: regex.source\n    };\n}\n\nexport function serializeMethods(destination : CrossDomainWindowType, domain : string | Array<string>, obj : Object) : Object {\n\n    return replaceObject({ obj }, (item, key) => {\n        if (typeof item === 'function') {\n            return serializeMethod(destination, domain, item, key.toString());\n        }\n\n        if (item instanceof Error) {\n            return serializeError(item);\n        }\n\n        if (window.Promise && item instanceof window.Promise) {\n            return serializePromise(destination, domain, item, key.toString());\n        }\n\n        if (ZalgoPromise.isPromise(item)) {\n            // $FlowFixMe\n            return serializeZalgoPromise(destination, domain, item, key.toString());\n        }\n\n        if (isRegex(item)) {\n            // $FlowFixMe\n            return serializeRegex(item);\n        }\n    }).obj;\n}\n\nexport function deserializeMethod(source : CrossDomainWindowType, origin : string, obj : Object) : Function {\n\n    function wrapper() : ZalgoPromise<mixed> {\n        let args = Array.prototype.slice.call(arguments);\n        return global.send(source, CONSTANTS.POST_MESSAGE_NAMES.METHOD, {\n            id:   obj.__id__,\n            name: obj.__name__,\n            args\n\n        }, { domain: origin, timeout: -1 }).then(({ data }) => {\n            return data.result;\n        }, err => {\n            throw err;\n        });\n    }\n\n    wrapper.__name__ = obj.__name__;\n    wrapper.__xdomain__ = true;\n\n    wrapper.source = source;\n    wrapper.origin = origin;\n\n    return wrapper;\n}\n\nexport function deserializeError(source : CrossDomainWindowType, origin : string, obj : Object) : Error {\n    let err = new Error(obj.__message__);\n    if (obj.__code__) {\n        // $FlowFixMe\n        err.code = obj.__code__;\n    }\n    return err;\n}\n\nexport function deserializeZalgoPromise(source : CrossDomainWindowType, origin : string, prom : Object) : ZalgoPromise<mixed> {\n    return new ZalgoPromise((resolve, reject) => deserializeMethod(source, origin, prom.__then__)(resolve, reject));\n}\n\nexport function deserializePromise(source : CrossDomainWindowType, origin : string, prom : Object) : ZalgoPromise<mixed> {\n    if (!window.Promise) {\n        return deserializeZalgoPromise(source, origin, prom);\n    }\n\n    return new window.Promise((resolve, reject) => deserializeMethod(source, origin, prom.__then__)(resolve, reject));\n}\n\nexport function deserializeRegex(source : CrossDomainWindowType, origin : string, item : Object) : RegExp {\n    // eslint-disable-next-line security/detect-non-literal-regexp\n    return new RegExp(item.__source__);\n}\n\nexport function deserializeMethods(source : CrossDomainWindowType, origin : string, obj : Object) : Object {\n\n    return replaceObject({ obj }, (item) => {\n        if (typeof item !== 'object' || item === null) {\n            return;\n        }\n\n        if (isSerialized(item, CONSTANTS.SERIALIZATION_TYPES.METHOD)) {\n            return deserializeMethod(source, origin, item);\n        }\n\n        if (isSerialized(item, CONSTANTS.SERIALIZATION_TYPES.ERROR)) {\n            return deserializeError(source, origin, item);\n        }\n\n        if (isSerialized(item, CONSTANTS.SERIALIZATION_TYPES.PROMISE)) {\n            return deserializePromise(source, origin, item);\n        }\n\n        if (isSerialized(item, CONSTANTS.SERIALIZATION_TYPES.ZALGO_PROMISE)) {\n            return deserializeZalgoPromise(source, origin, item);\n        }\n\n        if (isSerialized(item, CONSTANTS.SERIALIZATION_TYPES.REGEX)) {\n            return deserializeRegex(source, origin, item);\n        }\n\n    }).obj;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/serialize.js","/* @flow */\n\nimport { WeakMap } from 'cross-domain-safe-weakmap/src';\nimport { getAncestor, type CrossDomainWindowType } from 'cross-domain-utils/src';\nimport { ZalgoPromise } from 'zalgo-promise/src';\n\nimport { CONSTANTS } from '../conf';\nimport { global } from '../global';\n\nimport { noop } from './util';\n\nglobal.readyPromises = global.readyPromises || new WeakMap();\n\nexport function onHello(handler : ({ source? : CrossDomainWindowType, origin? : string }) => void) {\n    global.on(CONSTANTS.POST_MESSAGE_NAMES.HELLO, { domain: CONSTANTS.WILDCARD }, ({ source, origin }) => {\n        return handler({ source, origin });\n    });\n}\n\nexport function sayHello(win : CrossDomainWindowType) : ZalgoPromise<{ origin : string }> {\n    return global.send(win, CONSTANTS.POST_MESSAGE_NAMES.HELLO, {}, { domain: CONSTANTS.WILDCARD, timeout: -1 })\n        .then(({ origin }) => {\n            return { origin };\n        });\n}\n\nexport function initOnReady() {\n\n    onHello(({ source, origin }) => {\n        let promise = global.readyPromises.get(source) || new ZalgoPromise();\n        promise.resolve({ origin });\n        global.readyPromises.set(source, promise);\n    });\n\n    let parent = getAncestor();\n    if (parent) {\n        sayHello(parent).catch(noop);\n    }\n}\n\nexport function onChildWindowReady(win : mixed, timeout : number = 5000, name : string = 'Window') : ZalgoPromise<{ origin : string }> {\n\n    let promise = global.readyPromises.get(win);\n\n    if (promise) {\n        return promise;\n    }\n\n    promise = new ZalgoPromise();\n    global.readyPromises.set(win, promise);\n\n    if (timeout !== -1) {\n        setTimeout(() => promise.reject(new Error(`${ name } did not load after ${ timeout }ms`)), timeout);\n    }\n\n    return promise;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/ready.js","/* @flow */\n\nimport { isSameDomain, isSameTopWindow, isActuallySameDomain, getActualDomain, getDomain, type CrossDomainWindowType } from 'cross-domain-utils/src';\n\nimport { CONSTANTS } from '../../conf';\nimport { needsGlobalMessagingForBrowser } from '../../lib';\n\nexport let SEND_MESSAGE_STRATEGIES = {};\n\n\nSEND_MESSAGE_STRATEGIES[CONSTANTS.SEND_STRATEGIES.POST_MESSAGE] = (win : CrossDomainWindowType, serializedMessage : string, domain : (string | Array<string>)) => {\n\n    if (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n        try {\n            require('../../compat').emulateIERestrictions(window, win);\n        } catch (err) {\n            return;\n        }\n    }\n\n    let domains;\n\n    if (Array.isArray(domain)) {\n        domains = domain;\n    } else if (typeof domain === 'string') {\n        domains = [ domain ];\n    } else {\n        domains = [ CONSTANTS.WILDCARD ];\n    }\n\n    domains = domains.map(dom => {\n\n        if (dom.indexOf(CONSTANTS.MOCK_PROTOCOL) === 0) {\n\n            if (window.location.protocol === CONSTANTS.FILE_PROTOCOL) {\n                return CONSTANTS.WILDCARD;\n            }\n\n            if (!isActuallySameDomain(win)) {\n                throw new Error(`Attempting to send messsage to mock domain ${ dom }, but window is actually cross-domain`);\n            }\n\n            // $FlowFixMe\n            return getActualDomain(win);\n        }\n\n        if (dom.indexOf(CONSTANTS.FILE_PROTOCOL) === 0) {\n            return CONSTANTS.WILDCARD;\n        }\n\n        return dom;\n    });\n\n    domains.forEach(dom => {\n        return win.postMessage(serializedMessage, dom);\n    });\n};\n\nif (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n\n    let { sendBridgeMessage, needsBridgeForBrowser, isBridge } = require('../../bridge');\n\n    SEND_MESSAGE_STRATEGIES[CONSTANTS.SEND_STRATEGIES.BRIDGE] = (win : CrossDomainWindowType, serializedMessage : string, domain : string) => {\n\n        if (!needsBridgeForBrowser() && !isBridge()) {\n            return;\n        }\n\n        if (isSameDomain(win)) {\n            throw new Error(`Post message through bridge disabled between same domain windows`);\n        }\n\n        if (isSameTopWindow(window, win) !== false) {\n            throw new Error(`Can only use bridge to communicate between two different windows, not between frames`);\n        }\n\n        return sendBridgeMessage(win, serializedMessage, domain);\n    };\n}\n\nif (__POST_ROBOT__.__IE_POPUP_SUPPORT__ || __POST_ROBOT__.__GLOBAL_MESSAGE_SUPPORT__) {\n    \n    SEND_MESSAGE_STRATEGIES[CONSTANTS.SEND_STRATEGIES.GLOBAL] = (win : CrossDomainWindowType, serializedMessage : string) => {\n\n        if (!needsGlobalMessagingForBrowser()) {\n            return;\n        }\n\n        if (!isSameDomain(win)) {\n            throw new Error(`Post message through global disabled between different domain windows`);\n        }\n\n        if (isSameTopWindow(window, win) !== false) {\n            throw new Error(`Can only use global to communicate between two different windows, not between frames`);\n        }\n\n        // $FlowFixMe\n        let foreignGlobal = win[CONSTANTS.WINDOW_PROPS.POSTROBOT];\n\n        if (!foreignGlobal) {\n            throw new Error(`Can not find postRobot global on foreign window`);\n        }\n\n        return foreignGlobal.receiveMessage({\n            source: window,\n            origin: getDomain(),\n            data:   serializedMessage\n        });\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/drivers/send/strategies.js","/* @flow */\n\nimport { getDomain, isWindowClosed, type CrossDomainWindowType } from 'cross-domain-utils/src';\nimport { ZalgoPromise } from 'zalgo-promise/src';\n\nimport { CONSTANTS, CONFIG, POST_MESSAGE_NAMES_LIST } from '../../conf';\nimport { uniqueID, serializeMethods, getWindowType, jsonStringify, stringifyError } from '../../lib';\n\nimport { SEND_MESSAGE_STRATEGIES } from './strategies';\n\n\nfunction buildMessage(win : CrossDomainWindowType, message : Object, options = {}) : Object {\n\n    let id   = uniqueID();\n    let type = getWindowType();\n    let sourceDomain = getDomain(window);\n\n    return {\n        ...message,\n        ...options,\n        sourceDomain,\n        id:         message.id || id,\n        windowType: type\n    };\n}\n\n\nexport function sendMessage(win : CrossDomainWindowType, message : Object, domain : string | Array<string>) : ZalgoPromise<void> {\n    return ZalgoPromise.try(() => {\n\n        message = buildMessage(win, message, {\n            data: serializeMethods(win, domain, message.data),\n            domain\n        });\n\n        let level;\n\n        if (__DEBUG__) {\n            if (POST_MESSAGE_NAMES_LIST.indexOf(message.name) !== -1 || message.type === CONSTANTS.POST_MESSAGE_TYPE.ACK) {\n                level = 'debug';\n            } else if (message.ack === 'error') {\n                level = 'error';\n            } else {\n                level = 'info';\n            }\n\n            // eslint-disable-next-line no-console\n            console[level]('postrobot_send', message.type.replace(/^postrobot_message_/, ''), '::', message.name, '::', domain || CONSTANTS.WILDCARD, '\\n\\n', message);\n        }\n\n        if (win === window && !CONFIG.ALLOW_SAME_ORIGIN) {\n            throw new Error('Attemping to send message to self');\n        }\n\n        if (isWindowClosed(win)) {\n            throw new Error('Window is closed');\n        }\n\n        let messages = [];\n\n        let serializedMessage = jsonStringify({\n            [ CONSTANTS.WINDOW_PROPS.POSTROBOT ]: message\n        }, null, 2);\n\n        return ZalgoPromise.map(Object.keys(SEND_MESSAGE_STRATEGIES), strategyName => {\n\n            return ZalgoPromise.try(() => {\n\n                if (!CONFIG.ALLOWED_POST_MESSAGE_METHODS[strategyName]) {\n                    throw new Error(`Strategy disallowed: ${ strategyName }`);\n                }\n\n                return SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);\n\n            }).then(() => {\n                messages.push(`${ strategyName }: success`);\n                return true;\n            }, err => {\n                messages.push(`${ strategyName }: ${ stringifyError(err) }\\n`);\n                return false;\n            });\n\n        }).then(results => {\n\n            let success = results.some(Boolean);\n            let status = `${ message.type } ${ message.name } ${ success ? 'success' : 'error' }:\\n  - ${ messages.join('\\n  - ') }\\n`;\n\n            if (!success) {\n                throw new Error(status);\n            }\n        });\n    });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/drivers/send/index.js","/* @flow */\n\nimport { type ZalgoPromise } from 'zalgo-promise/src';\nimport { WeakMap } from 'cross-domain-safe-weakmap/src';\nimport { matchDomain, type CrossDomainWindowType } from 'cross-domain-utils/src';\n\nimport { global } from '../global';\nimport { isRegex } from '../lib';\nimport { CONSTANTS } from '../conf';\n\nexport function resetListeners() {\n    global.responseListeners = {};\n    global.requestListeners  = {};\n}\n\nglobal.responseListeners = global.responseListeners || {};\nglobal.requestListeners  = global.requestListeners  || {};\nglobal.WINDOW_WILDCARD   = global.WINDOW_WILDCARD   || new (function WindowWildcard() { /* pass */ })();\n\nglobal.erroredResponseListeners = global.erroredResponseListeners || {};\n\nconst __DOMAIN_REGEX__ = '__domain_regex__';\n\nexport type RequestListenerType = {\n    handler : ({ source : CrossDomainWindowType, origin : string, data : Object }) => (mixed | ZalgoPromise<mixed>),\n    handleError : (err : mixed) => void,\n    window : ?CrossDomainWindowType,\n    name : string,\n    domain : string | RegExp | Array<string>\n};\n\nexport type ResponseListenerType = {\n    name : string,\n    window : CrossDomainWindowType,\n    domain : (string | Array<string> | RegExp),\n    respond : (err : ?mixed, result : ?Object) => void,\n    ack? : ?boolean\n};\n\nexport function addResponseListener(hash : string, listener : ResponseListenerType) {\n    global.responseListeners[hash] = listener;\n}\n\nexport function getResponseListener(hash : string) : ResponseListenerType {\n    return global.responseListeners[hash];\n}\n\nexport function deleteResponseListener(hash : string) {\n    delete global.responseListeners[hash];\n}\n\nexport function markResponseListenerErrored(hash : string) {\n    global.erroredResponseListeners[hash] = true;\n}\n\nexport function isResponseListenerErrored(hash : string) : boolean {\n    return Boolean(global.erroredResponseListeners[hash]);\n}\n\nexport function getRequestListener({ name, win, domain } : { name : string, win : ?CrossDomainWindowType, domain : ?(string | RegExp) }) : ?RequestListenerType {\n\n    if (win === CONSTANTS.WILDCARD) {\n        win = null;\n    }\n\n    if (domain === CONSTANTS.WILDCARD) {\n        domain = null;\n    }\n\n    if (!name) {\n        throw new Error(`Name required to get request listener`);\n    }\n\n    let nameListeners = global.requestListeners[name];\n\n    if (!nameListeners) {\n        return;\n    }\n\n    for (let winQualifier of [ win, global.WINDOW_WILDCARD ]) {\n\n        let winListeners = winQualifier && nameListeners.get(winQualifier);\n\n        if (!winListeners) {\n            continue;\n        }\n\n        if (domain && typeof domain === 'string') {\n            if (winListeners[domain]) {\n                return winListeners[domain];\n            }\n\n            if (winListeners[__DOMAIN_REGEX__]) {\n                for (let { regex, listener } of winListeners[__DOMAIN_REGEX__]) {\n                    if (matchDomain(regex, domain)) {\n                        return listener;\n                    }\n                }\n            }\n        }\n\n        if (winListeners[CONSTANTS.WILDCARD]) {\n            return winListeners[CONSTANTS.WILDCARD];\n        }\n    }\n}\n\n// eslint-disable-next-line complexity\nexport function addRequestListener({ name, win, domain } : { name : string, win : ?CrossDomainWindowType, domain : ?(string | RegExp | Array<string>) }, listener : RequestListenerType) : { cancel : () => void } {\n\n    if (!name || typeof name !== 'string') {\n        throw new Error(`Name required to add request listener`);\n    }\n\n    if (Array.isArray(win)) {\n        let listenersCollection = [];\n\n        for (let item of win) {\n            listenersCollection.push(addRequestListener({ name, domain, win: item }, listener));\n        }\n\n        return {\n            cancel() {\n                for (let cancelListener of listenersCollection) {\n                    cancelListener.cancel();\n                }\n            }\n        };\n    }\n\n    if (Array.isArray(domain)) {\n        let listenersCollection = [];\n\n        for (let item of domain) {\n            listenersCollection.push(addRequestListener({ name, win, domain: item }, listener));\n        }\n\n        return {\n            cancel() {\n                for (let cancelListener of listenersCollection) {\n                    cancelListener.cancel();\n                }\n            }\n        };\n    }\n\n    let existingListener = getRequestListener({ name, win, domain });\n\n    if (!win || win === CONSTANTS.WILDCARD) {\n        win = global.WINDOW_WILDCARD;\n    }\n\n    domain = domain || CONSTANTS.WILDCARD;\n\n    if (existingListener) {\n        if (win && domain) {\n            throw new Error(`Request listener already exists for ${ name } on domain ${ domain.toString() } for ${ win === global.WINDOW_WILDCARD ? 'wildcard' : 'specified' } window`);\n        } else if (win) {\n            throw new Error(`Request listener already exists for ${ name } for ${ win === global.WINDOW_WILDCARD ? 'wildcard' : 'specified' } window`);\n        } else if (domain) {\n            throw new Error(`Request listener already exists for ${ name } on domain ${ domain.toString() }`);\n        } else {\n            throw new Error(`Request listener already exists for ${ name }`);\n        }\n    }\n\n    let requestListeners = global.requestListeners;\n\n    let nameListeners = requestListeners[name];\n\n    if (!nameListeners) {\n        nameListeners = new WeakMap();\n        requestListeners[name] = nameListeners;\n    }\n\n    let winListeners  = nameListeners.get(win);\n\n    if (!winListeners) {\n        winListeners = {};\n        nameListeners.set(win, winListeners);\n    }\n\n    let strDomain = domain.toString();\n\n    let regexListeners = winListeners[__DOMAIN_REGEX__];\n    let regexListener;\n\n    if (isRegex(domain)) {\n\n        if (!regexListeners) {\n            regexListeners = [];\n            winListeners[__DOMAIN_REGEX__] = regexListeners;\n        }\n\n        regexListener = { regex: domain, listener };\n\n        regexListeners.push(regexListener);\n\n    } else {\n        winListeners[strDomain] = listener;\n    }\n\n    return {\n        cancel() {\n            if (!winListeners) {\n                return;\n            }\n\n            delete winListeners[strDomain];\n\n            if (win && Object.keys(winListeners).length === 0) {\n                nameListeners.delete(win);\n            }\n\n            if (regexListener) {\n                regexListeners.splice(regexListeners.indexOf(regexListener, 1));\n            }\n        }\n\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/drivers/listeners.js","/* @flow */\n\nimport { ZalgoPromise } from 'zalgo-promise/src';\nimport { isWindowClosed, matchDomain, stringifyDomainPattern, type CrossDomainWindowType } from 'cross-domain-utils/src';\n\nimport { CONSTANTS } from '../../conf';\nimport { stringifyError, noop } from '../../lib';\nimport { sendMessage } from '../send';\nimport { getRequestListener, getResponseListener, deleteResponseListener, isResponseListenerErrored } from '../listeners';\n\nexport let RECEIVE_MESSAGE_TYPES = {\n\n    [ CONSTANTS.POST_MESSAGE_TYPE.ACK ](source : CrossDomainWindowType, origin : string, message : Object) {\n\n        if (isResponseListenerErrored(message.hash)) {\n            return;\n        }\n\n        let options = getResponseListener(message.hash);\n\n        if (!options) {\n            throw new Error(`No handler found for post message ack for message: ${ message.name } from ${ origin } in ${ window.location.protocol }//${ window.location.host }${ window.location.pathname }`);\n        }\n\n        if (!matchDomain(options.domain, origin)) {\n            throw new Error(`Ack origin ${ origin } does not match domain ${ options.domain.toString() }`);\n        }\n\n        options.ack = true;\n    },\n\n    [ CONSTANTS.POST_MESSAGE_TYPE.REQUEST ](source : CrossDomainWindowType, origin : string, message : Object) : ZalgoPromise<void> {\n\n        let options = getRequestListener({ name: message.name, win: source, domain: origin });\n\n        function respond(data) : ZalgoPromise<void> {\n\n            if (message.fireAndForget || isWindowClosed(source)) {\n                return ZalgoPromise.resolve();\n            }\n\n            return sendMessage(source, {\n                target: message.originalSource,\n                hash:   message.hash,\n                name:   message.name,\n                ...data\n            }, origin);\n        }\n\n        return ZalgoPromise.all([\n\n            respond({\n                type: CONSTANTS.POST_MESSAGE_TYPE.ACK\n            }),\n\n            ZalgoPromise.try(() => {\n\n                if (!options) {\n                    throw new Error(`No handler found for post message: ${ message.name } from ${ origin } in ${ window.location.protocol }//${ window.location.host }${ window.location.pathname }`);\n                }\n\n                if (!matchDomain(options.domain, origin)) {\n                    throw new Error(`Request origin ${ origin } does not match domain ${ options.domain.toString() }`);\n                }\n\n                let data = message.data;\n\n                return options.handler({ source, origin, data });\n\n            }).then(data => {\n\n                return respond({\n                    type: CONSTANTS.POST_MESSAGE_TYPE.RESPONSE,\n                    ack:  CONSTANTS.POST_MESSAGE_ACK.SUCCESS,\n                    data\n                });\n\n            }, err => {\n\n                let error = stringifyError(err).replace(/^Error: /, '');\n                // $FlowFixMe\n                let code = err.code;\n\n                return respond({\n                    type: CONSTANTS.POST_MESSAGE_TYPE.RESPONSE,\n                    ack:  CONSTANTS.POST_MESSAGE_ACK.ERROR,\n                    error,\n                    code\n                });\n            })\n\n        ]).then(noop).catch(err => {\n\n            if (options && options.handleError) {\n                return options.handleError(err);\n            } else {\n                throw err;\n            }\n        });\n    },\n\n    [ CONSTANTS.POST_MESSAGE_TYPE.RESPONSE ](source : CrossDomainWindowType, origin : string, message : Object) : void | ZalgoPromise<void> {\n\n        if (isResponseListenerErrored(message.hash)) {\n            return;\n        }\n\n        let options = getResponseListener(message.hash);\n\n        if (!options) {\n            throw new Error(`No handler found for post message response for message: ${ message.name } from ${ origin } in ${ window.location.protocol }//${ window.location.host }${ window.location.pathname }`);\n        }\n\n        if (!matchDomain(options.domain, origin)) {\n            throw new Error(`Response origin ${ origin } does not match domain ${ stringifyDomainPattern(options.domain) }`);\n        }\n\n        deleteResponseListener(message.hash);\n\n        if (message.ack === CONSTANTS.POST_MESSAGE_ACK.ERROR) {\n            let err = new Error(message.error);\n            if (message.code) {\n                // $FlowFixMe\n                err.code = message.code;\n            }\n            return options.respond(err, null);\n        } else if (message.ack === CONSTANTS.POST_MESSAGE_ACK.SUCCESS) {\n            let data = message.data || message.response;\n\n            return options.respond(null, { source, origin, data });\n        }\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/drivers/receive/types.js","/* @flow */\n\nimport { isWindowClosed, type CrossDomainWindowType } from 'cross-domain-utils/src';\n\nimport { CONSTANTS, POST_MESSAGE_NAMES_LIST } from '../../conf';\nimport { deserializeMethods, jsonParse, addEventListener, noop } from '../../lib';\nimport { global } from '../../global';\n\nimport { RECEIVE_MESSAGE_TYPES } from './types';\n\nglobal.receivedMessages = global.receivedMessages || [];\n\ntype MessageEvent = {\n    source : CrossDomainWindowType,\n    origin : string,\n    data : string\n};\n\nfunction parseMessage(message : string) : ?Object {\n\n    let parsedMessage;\n\n    try {\n        parsedMessage = jsonParse(message);\n    } catch (err) {\n        return;\n    }\n\n    if (!parsedMessage) {\n        return;\n    }\n\n    if (typeof parsedMessage !== 'object' || parsedMessage === null) {\n        return;\n    }\n\n    parsedMessage = parsedMessage[CONSTANTS.WINDOW_PROPS.POSTROBOT];\n\n    if (!parsedMessage || typeof parsedMessage !== 'object' || parsedMessage === null) {\n        return;\n    }\n\n    if (!parsedMessage.type || typeof parsedMessage.type !== 'string') {\n        return;\n    }\n\n    if (!RECEIVE_MESSAGE_TYPES[parsedMessage.type]) {\n        return;\n    }\n\n    return parsedMessage;\n}\n\n\nexport function receiveMessage(event : MessageEvent) {\n\n    if (!window || window.closed) {\n        return;\n    }\n\n    try {\n        if (!event.source) {\n            return;\n        }\n    } catch (err) {\n        return;\n    }\n\n    let { source, origin, data } = event;\n\n    let message = parseMessage(data);\n\n    if (!message) {\n        return;\n    }\n\n    if (!message.sourceDomain || typeof message.sourceDomain !== 'string') {\n        throw new Error(`Expected message to have sourceDomain`);\n    }\n\n    if (message.sourceDomain.indexOf(CONSTANTS.MOCK_PROTOCOL) === 0 || message.sourceDomain.indexOf(CONSTANTS.FILE_PROTOCOL) === 0) {\n        origin = message.sourceDomain;\n    }\n\n    if (global.receivedMessages.indexOf(message.id) === -1) {\n        global.receivedMessages.push(message.id);\n    } else {\n        return;\n    }\n\n    if (__DEBUG__) {\n        let level;\n\n        if (POST_MESSAGE_NAMES_LIST.indexOf(message.name) !== -1 || message.type === CONSTANTS.POST_MESSAGE_TYPE.ACK) {\n            level = 'debug';\n        } else if (message.ack === 'error') {\n            level = 'error';\n        } else {\n            level = 'info';\n        }\n        \n        // eslint-disable-next-line no-console\n        console[level]('postrobot_receive', message.type.replace(/^postrobot_message_/, ''), '::', message.name, '::', origin, '\\n\\n', message);\n    }\n\n    if (isWindowClosed(source) && !message.fireAndForget) {\n        return;\n    }\n\n    if (message.data) {\n        message.data = deserializeMethods(source, origin, message.data);\n    }\n\n    RECEIVE_MESSAGE_TYPES[message.type](source, origin, message);\n}\n\nexport function messageListener(event : { source : CrossDomainWindowType, origin : string, data : string, sourceElement : CrossDomainWindowType, originalEvent? : { origin : string } }) {\n\n    try {\n        noop(event.source);\n    } catch (err) {\n        return;\n    }\n\n    // $FlowFixMe\n    let messageEvent : MessageEvent = {\n        source: event.source || event.sourceElement,\n        origin: event.origin || (event.originalEvent && event.originalEvent.origin),\n        data:   event.data\n    };\n\n    if (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n        try {\n            require('../../compat').emulateIERestrictions(messageEvent.source, window);\n        } catch (err) {\n            return;\n        }\n    }\n\n    receiveMessage(messageEvent);\n}\n\nexport function listenForMessages() {\n    addEventListener(window, 'message', messageListener);\n}\n\nglobal.receiveMessage = receiveMessage;\n\n\n\n// WEBPACK FOOTER //\n// ./src/drivers/receive/index.js","/* @flow */\n\nimport { WeakMap } from 'cross-domain-safe-weakmap/src';\nimport { ZalgoPromise } from 'zalgo-promise/src';\nimport { getAncestor, isAncestor, isWindowClosed, getDomain, matchDomain, type CrossDomainWindowType } from 'cross-domain-utils/src';\n\nimport { CONFIG, CONSTANTS } from '../conf';\nimport { sendMessage, addResponseListener, deleteResponseListener, markResponseListenerErrored, type ResponseListenerType } from '../drivers';\nimport { uniqueID, onChildWindowReady, sayHello, isRegex } from '../lib';\nimport { global } from '../global';\n\nglobal.requestPromises = global.requestPromises || new WeakMap();\n\ntype WindowResolverType = CrossDomainWindowType | string | HTMLIFrameElement;\n\ntype RequestOptionsType = {\n    window? : ?WindowResolverType,\n    domain? : ?(string | Array<string> | RegExp),\n    name? : ?string,\n    data? : ?Object,\n    fireAndForget? : ?boolean,\n    timeout? : ?number\n};\n\ntype ResponseMessageEvent = {\n    source : CrossDomainWindowType,\n    origin : string,\n    data : Object\n};\n\nexport function request(options : RequestOptionsType) : ZalgoPromise<ResponseMessageEvent> {\n\n    let prom = ZalgoPromise.try(() => {\n\n        if (!options.name) {\n            throw new Error('Expected options.name');\n        }\n\n        let name = options.name;\n        let targetWindow : ?CrossDomainWindowType;\n        let domain : string | Array<string> | RegExp;\n\n        if (typeof options.window === 'string') {\n            let el = document.getElementById(options.window);\n\n            if (!el) {\n                throw new Error(`Expected options.window ${ Object.prototype.toString.call(options.window) } to be a valid element id`);\n            }\n\n            if (el.tagName.toLowerCase() !== 'iframe') {\n                throw new Error(`Expected options.window ${ Object.prototype.toString.call(options.window) } to be an iframe`);\n            }\n\n            // $FlowFixMe\n            if (!el.contentWindow) {\n                throw new Error('Iframe must have contentWindow.  Make sure it has a src attribute and is in the DOM.');\n            }\n\n            // $FlowFixMe\n            targetWindow = el.contentWindow;\n\n        } else if (options.window instanceof HTMLIFrameElement) {\n\n            if (options.window.tagName.toLowerCase() !== 'iframe') {\n                throw new Error(`Expected options.window ${ Object.prototype.toString.call(options.window) } to be an iframe`);\n            }\n\n            if (options.window && !options.window.contentWindow) {\n                throw new Error('Iframe must have contentWindow.  Make sure it has a src attribute and is in the DOM.');\n            }\n\n            if (options.window && options.window.contentWindow) {\n                // $FlowFixMe\n                targetWindow = options.window.contentWindow;\n            }\n        } else {\n            targetWindow = options.window;\n        }\n\n        if (!targetWindow) {\n            throw new Error('Expected options.window to be a window object, iframe, or iframe element id.');\n        }\n\n        const win = targetWindow;\n\n        domain = options.domain || CONSTANTS.WILDCARD;\n\n        let hash = `${ options.name }_${ uniqueID() }`;\n\n        if (isWindowClosed(win)) {\n            throw new Error('Target window is closed');\n        }\n\n        let hasResult = false;\n\n        let requestPromises = global.requestPromises.get(win);\n\n        if (!requestPromises) {\n            requestPromises = [];\n            global.requestPromises.set(win, requestPromises);\n        }\n\n        let requestPromise = ZalgoPromise.try(() => {\n\n            if (isAncestor(window, win)) {\n                return onChildWindowReady(win, options.timeout || CONFIG.CHILD_WINDOW_TIMEOUT);\n            }\n\n        }).then(({ origin } = {}) => {\n\n            if (isRegex(domain) && !origin) {\n                return sayHello(win);\n            }\n\n        }).then(({ origin } = {}) => {\n\n            if (isRegex(domain)) {\n                if (!matchDomain(domain, origin)) {\n                    throw new Error(`Remote window domain ${ origin } does not match regex: ${ domain.toString() }`);\n                }\n\n                domain = origin;\n            }\n\n            if (typeof domain !== 'string' && !Array.isArray(domain)) {\n                throw new TypeError(`Expected domain to be a string or array`);\n            }\n\n            const actualDomain = domain;\n\n            return new ZalgoPromise((resolve, reject) => {\n\n                let responseListener : ResponseListenerType;\n\n                if (!options.fireAndForget) {\n                    responseListener = {\n                        name,\n                        window: win,\n                        domain: actualDomain,\n                        respond(err, result) {\n                            if (!err) {\n                                hasResult = true;\n                                requestPromises.splice(requestPromises.indexOf(requestPromise, 1));\n                            }\n\n                            if (err) {\n                                reject(err);\n                            } else {\n                                resolve(result);\n                            }\n                        }\n                    };\n\n                    addResponseListener(hash, responseListener);\n                }\n\n                sendMessage(win, {\n                    type:          CONSTANTS.POST_MESSAGE_TYPE.REQUEST,\n                    hash,\n                    name,\n                    data:          options.data,\n                    fireAndForget: options.fireAndForget\n                }, actualDomain).catch(reject);\n\n                if (options.fireAndForget) {\n                    return resolve();\n                }\n\n                let ackTimeout = CONFIG.ACK_TIMEOUT;\n                let resTimeout = options.timeout || CONFIG.RES_TIMEOUT;\n\n                let cycleTime = 100;\n\n                let cycle = () => {\n\n                    if (hasResult) {\n                        return;\n                    }\n\n                    if (isWindowClosed(win)) {\n\n                        if (!responseListener.ack) {\n                            return reject(new Error(`Window closed for ${ name } before ack`));\n                        }\n\n                        return reject(new Error(`Window closed for ${ name } before response`));\n                    }\n\n                    ackTimeout = Math.max(ackTimeout - cycleTime, 0);\n                    if (resTimeout !== -1) {\n                        resTimeout = Math.max(resTimeout - cycleTime, 0);\n                    }\n\n                    let hasAck = responseListener.ack;\n\n                    if (hasAck) {\n\n                        if (resTimeout === -1) {\n                            return;\n                        }\n\n                        cycleTime = Math.min(resTimeout, 2000);\n\n                    } else if (ackTimeout === 0) {\n                        return reject(new Error(`No ack for postMessage ${ name } in ${ getDomain() } in ${ CONFIG.ACK_TIMEOUT }ms`));\n\n                    } else if (resTimeout === 0) {\n                        return reject(new Error(`No response for postMessage ${ name } in ${ getDomain() } in ${ options.timeout || CONFIG.RES_TIMEOUT }ms`));\n                    }\n\n                    setTimeout(cycle, cycleTime);\n                };\n\n                setTimeout(cycle, cycleTime);\n            });\n        });\n\n        requestPromise.catch(() => {\n            markResponseListenerErrored(hash);\n            deleteResponseListener(hash);\n        });\n\n        requestPromises.push(requestPromise);\n\n        return requestPromise;\n    });\n\n    return prom;\n}\n\nexport function send(window : WindowResolverType, name : string, data : ?Object, options : ?RequestOptionsType) : ZalgoPromise<ResponseMessageEvent> {\n\n    options = options || {};\n    options.window = window;\n    options.name = name;\n    options.data = data;\n\n    return request(options);\n}\n\nexport function sendToParent(name : string, data : ?Object, options : ?RequestOptionsType) : ZalgoPromise<ResponseMessageEvent> {\n\n    let win = getAncestor();\n\n    if (!win) {\n        return new ZalgoPromise((resolve, reject) => reject(new Error('Window does not have a parent')));\n    }\n\n    return send(win, name, data, options);\n}\n\nexport function client(options : RequestOptionsType = {}) : { send : (string, ?Object) => ZalgoPromise<ResponseMessageEvent> } {\n\n    if (!options.window) {\n        throw new Error(`Expected options.window`);\n    }\n\n    const win = options.window;\n\n    return {\n        send(name : string, data : ?Object) : ZalgoPromise<ResponseMessageEvent> {\n            return send(win, name, data, options);\n        }\n    };\n}\n\nglobal.send = send;\n\n\n\n// WEBPACK FOOTER //\n// ./src/public/client.js","/* @flow */\n\nimport { isWindowClosed, type CrossDomainWindowType } from 'cross-domain-utils/src';\nimport { ZalgoPromise } from 'zalgo-promise/src';\n\nimport { once as onceFunction, safeInterval } from '../lib';\nimport { addRequestListener, type RequestListenerType } from '../drivers';\nimport { CONSTANTS } from '../conf';\nimport { global } from '../global';\n\ntype ErrorHandlerType = (err : mixed) => void;\ntype HandlerType = ({ source : CrossDomainWindowType, origin : string, data : Object }) => (void | mixed | ZalgoPromise<mixed>);\n\ntype ServerOptionsType = {\n    handler? : ?HandlerType,\n    errorHandler? : ?ErrorHandlerType,\n    window? : CrossDomainWindowType,\n    name? : ?string,\n    domain? : ?(string | RegExp | Array<string>),\n    once? : ?boolean,\n    errorOnClose? : ?boolean\n};\n\nexport function listen(options : ServerOptionsType) : { cancel : () => void } {\n\n    if (!options.name) {\n        throw new Error('Expected options.name');\n    }\n\n    if (!options.handler) {\n        throw new Error('Expected options.handler');\n    }\n\n    const name = options.name;\n    const win = options.window;\n    const domain = options.domain;\n\n    let listenerOptions : RequestListenerType = {\n        handler:     options.handler,\n        handleError: options.errorHandler || (err => {\n            throw err;\n        }),\n        window: win,\n        domain: domain || CONSTANTS.WILDCARD,\n        name\n    };\n\n    let requestListener = addRequestListener({ name, win, domain }, listenerOptions);\n\n    if (options.once) {\n        let handler = listenerOptions.handler;\n        listenerOptions.handler = onceFunction(function listenOnce() : mixed | ZalgoPromise<mixed> {\n            requestListener.cancel();\n            return handler.apply(this, arguments);\n        });\n    }\n\n    if (listenerOptions.window && options.errorOnClose) {\n        let interval = safeInterval(() => {\n            if (win && typeof win === 'object' && isWindowClosed(win)) {\n                interval.cancel();\n                listenerOptions.handleError(new Error('Post message target window is closed'));\n            }\n        }, 50);\n    }\n\n    return {\n        cancel() {\n            requestListener.cancel();\n        }\n    };\n}\n\nexport function on(name : string, options : ServerOptionsType | HandlerType, handler : ?HandlerType) : { cancel : () => void } {\n\n    if (typeof options === 'function') {\n        handler = options;\n        options = {};\n    }\n\n    options = options || {};\n\n    options.name = name;\n    options.handler = handler || options.handler;\n\n    return listen(options);\n}\n\nexport function once(name : string, options : ?(ServerOptionsType | HandlerType) = {}, handler : ?HandlerType) : ZalgoPromise<{ source : mixed, origin : string, data : Object }> {\n\n    if (typeof options === 'function') {\n        handler = options;\n        options = {};\n    }\n\n    options = options || {};\n    handler = handler || options.handler;\n    let errorHandler = options.errorHandler;\n\n    let promise = new ZalgoPromise((resolve, reject) => {\n\n        options = options || {};\n\n        options.name = name;\n        options.once = true;\n\n        options.handler = (event) => {\n            resolve(event);\n            if (handler) {\n                return handler(event);\n            }\n        };\n\n        options.errorHandler = (err) => {\n            reject(err);\n            if (errorHandler) {\n                return errorHandler(err);\n            }\n        };\n    });\n\n    let onceListener = listen(options);\n    promise.cancel = onceListener.cancel;\n\n    return promise;\n}\n\nexport function listener(options : ServerOptionsType = {}) : { on : (name : string, handler : HandlerType) => { cancel : () => void } } {\n\n    return {\n        on(name : string, handler : HandlerType) : { cancel : () => void } {\n            return on(name, options, handler);\n        }\n    };\n}\n\nglobal.on = on;\n\n\n\n// WEBPACK FOOTER //\n// ./src/public/server.js","/* @flow */\n\nimport { CONSTANTS } from '../conf';\nimport { messageListener } from '../drivers';\n\nexport { CONFIG, CONSTANTS } from '../conf';\n\nexport function disable() {\n    delete window[CONSTANTS.WINDOW_PROPS.POSTROBOT];\n    window.removeEventListener('message', messageListener);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/public/config.js","/* @flow */\n\nimport { getAncestor } from 'cross-domain-utils/src';\n\nexport * from './client';\nexport * from './server';\nexport * from './config';\n\nexport let parent = getAncestor();\n\n\n\n// WEBPACK FOOTER //\n// ./src/public/index.js","/* @flow */\n\nimport { type CrossDomainWindowType } from 'cross-domain-utils/src';\n\nimport { global } from './global';\n\nexport function cleanUpWindow(win : CrossDomainWindowType) {\n\n    // global.tunnelWindows\n    // global.bridges\n    // global.popupWindowsByName\n    // global.responseListeners\n    // global.requestListeners\n\n    let requestPromises = global.requestPromises.get(win);\n\n    if (requestPromises) {\n        for (let promise of requestPromises) {\n            promise.reject(new Error(`No response from window - cleaned up`));\n        }\n    }\n\n    if (global.popupWindowsByWin) {\n        global.popupWindowsByWin.delete(win);\n    }\n\n    if (global.remoteWindows) {\n        global.remoteWindows.delete(win);\n    }\n\n    global.requestPromises.delete(win);\n    global.methods.delete(win);\n    global.readyPromises.delete(win);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/clean.js","/* @flow */\n\nimport { initOnReady, listenForMethods } from './lib';\nimport { listenForMessages } from './drivers';\nimport { global } from './global';\nimport { on, send } from './public';\n\nexport * from './public';\nexport { cleanUpWindow } from './clean';\nexport { ZalgoPromise as Promise } from 'zalgo-promise/src';\nexport let bridge = __POST_ROBOT__.__IE_POPUP_SUPPORT__ ? require('./bridge/interface') : null;\n\nexport function init() {\n    if (!global.initialized) {\n        listenForMessages();\n\n        if (__POST_ROBOT__.__IE_POPUP_SUPPORT__) {\n            require('./bridge').openTunnelToOpener();\n        }\n\n        initOnReady();\n        listenForMethods({ on, send });\n    }\n\n    global.initialized = true;\n}\n\ninit();\n\n\n\n// WEBPACK FOOTER //\n// ./src/interface.js","/* @flow */\n\n// eslint-disable-next-line import/no-namespace\nimport * as INTERFACE from './interface';\n\nexport * from './interface';\nexport default INTERFACE;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}